unit Kalkulator2021;

interface
 uses
    Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
     UnitMiesieczne, unitMiesiaceRoku;

Const
  ZUS_LIMIT = 157770;
  WOLNA_KW = 43.76;
  PROC_EMERYT = 0.0976;
  PROC_RENTOW = 0.015;
  PROC_CHOROB = 0.0245;
  PROC_ZDR_OD = 0.0775;
  PROC_ZDR = 0.09;
  KOSZT_WK = 300;
  KOSZT_MN = 250;
  PIT_MN = 0.17;
  PIT_W = 0.32;
  PRÓG_PIT = 85528;

type
  MSC = UnitMiesieczne.miesieczne;
  tablicaMiesiêcy = UnitMiesieczne.tablicaMiesiêcy;
  Kalk2021 = Class
  var
    tm: tablicaMiesiêcy;
    constructor stwórzTablicê(brutto, kosztPrzychodu: Double; ulga26: Boolean);
    function liczRentowe(brutto, rentoweRazem: Double): Double;
    function dajTablicê: tablicaMiesiêcy;
    function liczEmerytalne(brutto, emerytalneRazem: Double): Double;
    function liczPreZaliczkê(podstawa, podstawaRazem: Double): Double;
    function liczNieskonczone26(podstawa, podstawaRazem, BruttoRazem, zdrDoOdliczenia: Double): Double;
    function toString: String;
  End;

implementation

function zredukujDoSetnych(liczba: double): double;
begin
  liczba := liczba * 100;
  liczba := round(liczba);
  result := liczba / 100;
end;

function Kalk2021.liczEmerytalne(brutto, emerytalneRazem: Double): Double;
begin
  if brutto < emerytalneRazem then
    result := zredukujDoSetnych(brutto * PROC_EMERYT)
  else if (brutto > emerytalneRazem) AND (emerytalneRazem > 0) then
    result := zredukujDoSetnych(emerytalneRazem * PROC_EMERYT)
  else
    result := 0;
end;

function Kalk2021.liczRentowe(brutto, rentoweRazem: Double): Double;
begin
  if brutto < rentoweRazem then
    result := zredukujDoSetnych(brutto * PROC_RENTOW)
  else if (brutto > rentoweRazem) AND (rentoweRazem > 0) then
    result := zredukujDoSetnych(rentoweRazem * PROC_RENTOW)
  else
    result := 0;
end;

function Kalk2021.liczPreZaliczkê(podstawa, podstawaRazem: Double): Double;
var
  czêœæ1, czêœæ2, zaliczka: Double;
begin
  if podstawaRazem < PRÓG_PIT then
  begin
  zaliczka:= zredukujDoSetnych(podstawa * PIT_MN - WOLNA_KW);
  if (zaliczka>0) then result:=zaliczka else result:= 0;
  end
  else if (podstawaRazem - podstawa < PRÓG_PIT) AND (podstawaRazem > PRÓG_PIT)
  then
  begin
    czêœæ1 := PRÓG_PIT - (podstawaRazem - podstawa);
    czêœæ1 := czêœæ1 * PIT_MN;
    czêœæ2 := (podstawaRazem - PRÓG_PIT) * PIT_W;
    result := zredukujDoSetnych(czêœæ1 + czêœæ2 - WOLNA_KW)
  end
  else
    result := zredukujDoSetnych(podstawa * PIT_W);
end;

function Kalk2021.liczNieskonczone26(podstawa, podstawaRazem, BruttoRazem, zdrDoOdliczenia: Double): Double;
var
  czêœæ1, czêœæ2, zaliczka: Double;
begin
  if BruttoRazem < PRÓG_PIT then
  begin
  zaliczka:= 0
  end
  else if (BruttoRazem > PRÓG_PIT) and (PodstawaRazem < PRÓG_PIT *2) then
  begin
  zaliczka:= round(zredukujDoSetnych(podstawa * PIT_MN)-zdrDoOdliczenia-WOLNA_KW)
  end
  else if (PodstawaRazem > PRÓG_PIT * 2) and (PodstawaRazem < PRÓG_PIT * 2 + podstawa) then
  begin
  czêœæ2:= podstawaRazem - (PRÓG_PIT *2);
  czêœæ1:= podstawa - czêœæ2;
  czêœæ1:= czêœæ1 * 0.17;
  czêœæ2:= czêœæ2 * 0.32;
  zaliczka:= round(czêœæ1+czêœæ2-zdrDoOdliczenia-WOLNA_KW);
  end
  else
  begin
  zaliczka:= round(zredukujDoSetnych(podstawa * PIT_W)-zdrDoOdliczenia);
  end;
  result:=zaliczka;
end;

 constructor Kalk2021.stwórzTablicê(brutto, kosztPrzychodu: Double; ulga26: Boolean);
var
  I: Integer;
var
  bruttoRazem, spo³eczneRazem, podstawaRazem, podstawaZdr, zdrDoOdliczenia, prezaliczka: Double;
begin
  spo³eczneRazem := ZUS_LIMIT;
  podstawaRazem := 0;
  for I := 1 to 12 do
  begin
    tm[I] := MSC.Create;
    bruttoRazem:= bruttoRazem+brutto;
    tm[I].emerytalne := liczEmerytalne(brutto, spo³eczneRazem);
    tm[I].rentowe := liczRentowe(brutto, spo³eczneRazem);
    tm[I].chorobowe := brutto * PROC_CHOROB;

    podstawaZdr:= zredukujDoSetnych(brutto - tm[I].emerytalne - tm[I].rentowe - tm[I].chorobowe);
    tm[I].podstawa := round(podstawaZdr - kosztPrzychodu);
    podstawaRazem := podstawaRazem + tm[I].podstawa;
    zdrDoOdliczenia:= podstawaZdr * PROC_ZDR_OD;
    tm[I].prezaliczka:= liczPrezaliczkê(tm[I].podstawa, podstawaRazem);

    if(tm[i].prezaliczka-zdrDoOdliczenia>0) then
    tm[i].zaliczka:= round(tm[i].prezaliczka-zdrDoOdliczenia)
    else
    tm[i].zaliczka:= 0;

    if ulga26 = true then
    tm[i].zaliczka:= liczNieskonczone26(tm[I].podstawa, podstawaRazem, bruttoRazem, zdrDoOdliczenia);

    tm[I].zdrowotne := zredukujDoSetnych(podstawaZdr * PROC_ZDR);

    if (tm[i].zdrowotne>tm[i].prezaliczka) then tm[i].zdrowotne:= tm[i].prezaliczka;

    tm[I].netto := zredukujDoSetnych(podstawaZdr - tm[I].zaliczka - tm[I].zdrowotne);
    spo³eczneRazem := spo³eczneRazem - brutto;
    self.Free;
  end;


end;

function Kalk2021.toString: String;
var I: Integer;
    nettoRazem: Double;
    msc_roku: unitMiesiaceRoku.tStringArray;
    tekst: String;
begin
for I := 1 to 12 do
begin
  msc_roku := unitMiesiaceRoku.MIESIACE_ROKU;
  tekst := tekst
  + msc_roku[I]
  + ' - spo³eczne: '+ floatToStr(tm[i].emerytalne + tm[i].rentowe + tm[i].chorobowe)
  //+ ' emerytalne: '+ floatToStr(tm[i].emerytalne)
  //+ ' rentowe: '+ floatToStr(tm[i].rentowe)
  //+ ' chorobowe: '+floatToStr(tm[i].chorobowe)
  + ' podstawa: ' + floatToStr(tm[i].podstawa)
  + ' zaliczka PIT: ' + floatToStr(tm[i].zaliczka)
  + ' zdrowotne: ' + floatToStr(tm[i].zdrowotne)
  + ' netto ' + floatToStr(tm[i].netto)
  + sLineBreak;
  nettoRazem:= nettoRazem+tm[i].netto;
end;
  result:= tekst+'Kwota netto w skali roku to: '+floatToStr(nettoRazem);
end;

function Kalk2021.dajTablicê: tablicaMiesiêcy;
begin
  result := tm;
end;

end.
